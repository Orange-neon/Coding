#include <bits/stdc++.h>
using namespace std;
int n,m, ans;
bool valid = true;
vector<int> dx = {-1, 1, 0, 0};
vector<int> dy = {0, 0, -1, 1};
vector<vector<char>> maze;
vector<vector<int>> visited;
vector<vector<int>> battleships_visited;

bool is_valid(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n && !visited[y][x];
}

bool is_battleship_valid(int x, int y) {
    return x >= 0 && x < m && y >= 0 && y < n && !battleships_visited[y][x] && maze[y][x] == '#';
}

void battleship_bfs(int x, int y) {
    int height=1;
    int max_y = 0;
    int min_y = INT_MAX;
    queue<pair<int, int>> nq;
    queue<pair<int, int>> q;
    nq.push({x,y});
    q.push({x,y});
    battleships_visited[y][x] = 1;
    while (!nq.empty()) {
        int sx = nq.front().first, sy = nq.front().second;
        nq.pop();
        for (int i = 2; i < 4; ++i) {
            int nx = sx + dx[i], ny = sy + dy[i];
            if (is_battleship_valid(nx, ny)) {
                if (ny > max_y) {
                    max_y = ny;
                } else if (ny < min_y) {
                    min_y = ny;
                }
                battleships_visited[ny][nx] = 1;
                nq.push({nx, ny});
                q.push({nx, ny});
                ++height;
            }
        }
    }
    int started = 0, left = 1;
    while (!q.empty()) {
        int bx = q.front().first, by = q.front().second;
        q.pop();
        if (left == 1) {
            int nx = bx + dx[0], ny = by;
            if (is_battleship_valid(nx, ny)) {
                battleships_visited[ny][nx] = 1;
                q.push({nx, ny});
                if (ny == max_y) {
                    started = 1;
                } else if (ny == min_y) {
                    started = 0;
                    left *= -1;
                }
            } else if (started) {
                valid = false;
                return;
            }

        } else {
            int nx = bx + dx[1], ny = by;
            if (is_battleship_valid(nx, ny)) {
                battleships_visited[ny][nx] = 1;
                q.push({nx, ny});
                if (ny == max_y) {
                    started = 1;
                } else if (ny == min_y) {
                    started = 0;
                    left *= -1;
                }
            } else if (started) {
                valid = false;
                return;
            }
        }
    }
}
void bfs() {
    queue<pair<int, int>> q;
    q.push({0,0});
    visited[0][0] = 1;
    while (!q.empty()) {
        auto x = q.front().first, y = q.front().second;
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (is_valid(nx, ny)) {
                q.push({nx, ny});
                visited[ny][nx] = 1;
                if (is_battleship_valid[ny][nx]) {
                    battleships_visited[ny][nx] = 1;
                    battleship_bfs(nx, ny);
                    if (!valid) {
                        return;
                    }
                    ++ans;
                }
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        vector<char> row(m);
        for (int j = 0; j < m; ++j) {
            cin >> row[j];
        }
        maze.push_back(row);
    }
    visited.resize(n, vector<int> (m, 0));
    battleships_visited.resize(n, vector<int> (m, 0));
    bfs();
    if (!valid) {
        cout << "Bad placement.";
    } else {
        cout << "There are " << ans << " ships.";
    }
}